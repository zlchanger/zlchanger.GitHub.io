---
layout: post
title: java锁机制
date: 2018/8/31
categories: blog
tags: [java]
description: 一个优秀的程序员对于java多线程所具备的知识点（面试必备）。

---
注：本文转载自Tison的博客的[《java 多线程总结篇4——锁机制》](https://www.cnblogs.com/tison/p/8283233.html)


## 1、ReadWriteLock是什么？

读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，我们只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！读写锁接口：ReadWriteLock，它的具体实现类为：ReentrantReadWriteLock。

    public class ReadWriteCache {
        private static Map<String, Object> data = new HashMap<>();
        private static ReadWriteLock lock = new ReentrantReadWriteLock(false);
        private static Lock rlock = lock.readLock();
        private static Lock wlock = lock.writeLock();
    
        public static Object get(String key) {
            rlock.lock();
            try {
                return data.get(key);
            } finally {
                rlock.unlock();
            }
        }
    
        public static Object put(String key, Object value) {
            wlock.lock();
            try {
                return data.put(key, value);
            } finally {
                wlock.unlock();
            }
        }
    
    }
    
示例中HashMap（本身线程不安全）作为缓存，通过readLock、writeLock方法分别获取读锁和写锁。

### 注意点：
在某个线程持有读锁的情况下，任何一个线程都不能获取到写锁（在某个线程获取读锁，为保证数据的一致性，并不能将该线程升级为写锁，因为其他线程可能也获取到读锁）；
在某个线程持有写锁的情况下，该线程可以获取到读锁（当一个线程获取到读锁，它一定独占了读写锁，因此可以让该线程获取到读锁）
### 总结： 
一个线程要想同时持有写锁和读锁，必须先获取写锁再获取读锁；
写锁可以“降级”为读锁；
读锁不能“升级”为写锁。

## 2、乐观锁与悲观锁

乐观锁原理：当使用乐观锁时，我们一般会在数据字段上加上一个version字段，每次进行update时更新version+1，同时update时会附加上条件version，这样即使多个线程在进行数据库读时获取到的数据一致，但在进行update时，数据库的锁机制（行锁）会锁行，当有一个update完后，version也加一了，其他的update将失败。此锁适合多读机制
悲观锁：每次拿数据时都会认为别人也会进行修改，所以拿数据时会进行上锁，应用传统的关系型数据库（行锁，表锁，读锁，写锁等）。

## 3、其他锁 （重入锁、自旋锁、偏向锁、轻量级锁、公平锁、非公平锁）

* 重入锁（ReentrantLock）

是一种递归无阻塞的同步机制。重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。

* 自旋锁

由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。
线程发现锁定了，不是睡眠等待，而是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区。

* 轻量级锁

是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。

* 公平锁

在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己

* 非公平锁

比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。

##4、什么时候应该使用可重入锁？

场景1：如果已加锁，则不再重复加锁。a、忽略重复加锁。b、用在界面交互时点击执行较长时间请求操作时，防止多次点击导致后台重复执行（忽略重复触发）。以上两种情况多用于进行非重要任务防止重复执行，（如：清除无用临时文件，检查某些资源的可用性，数据备份操作等）

场景2：如果发现该操作已经在执行，则尝试等待一段时间，等待超时则不执行（尝试等待执行）这种其实属于场景2的改进，等待获得锁的操作有一个时间的限制，如果超时则放弃执行。用来防止由于资源处理不当长时间占用导致死锁情况（大家都在等待资源，导致线程队列溢出）。

场景3：如果发现该操作已经加锁，则等待一个一个加锁（同步执行，类似synchronized）这种比较常见大家也都在用，主要是防止资源使用冲突，保证同一时间内只有一个操作可以使用该资源。但与synchronized的明显区别是性能优势（伴随jvm的优化这个差距在减小）。同时Lock有更灵活的锁定方式，公平锁与不公平锁，而synchronized永远是公平的。这种情况主要用于对资源的争抢（如：文件操作，同步消息发送，有状态的操作等）

场景4：可中断锁。synchronized与Lock在默认情况下是不会响应中断(interrupt)操作，会继续执行完。lockInterruptibly()提供了可中断锁来解决此问题。（场景3的另一种改进，没有超时，只能等待中断或执行完毕）这种情况主要用于取消某些操作对资源的占用。如：（取消正在同步运行的操作，来防止不正常操作长时间占用造成的阻塞）

## 5、Java中活锁和死锁

### 死锁发生的四要素
1、互斥条件：线程对资源的访问具有排他性；
2、请求和保持条件：线程占有资源A，请求资源B，并一致占有资源A
3、不剥夺条件：线程占有资源A，其他线程无法剥夺资源A
4、环路等待条件：线程间的资源等待形成一个环路，互相等待中，且又都占有。

### 活锁
线程间的资源可以让其他需要的线程进行使用。

## 6、避免死锁
1、线程在进行资源占有时，即使释放自身占有的线程；（破坏条件2）
2、对各线程请求的资源做各优先级，优先级高的线程优先占有资源（破坏等待条件）

## 7、分布式锁

### 基于数据库实现分布式锁

一、数据库表设计


| field | type | comment |
| ------ | ------ | ------ |
| ID | bigint | 主键 |
| METHOD_NAME | varchar | 方法操作名 |
| DESC | varchar | 描述 |
| CREATE_TIME | timestamp | 创建时间 |
| UPDATE_TIME | timestamp | 更新时间 |

* 对METHOD_NAME创建唯一索引（UNIQUE KEY）

1、原理

利用数据库的唯一索引，对METHOD_NAME创建唯一索引，保证该数据的唯一性，确保某个操作的唯一性。

2、操作

* 加锁

        insert into methodLock(method_name,desc) values (‘method_name’,‘desc’)
        
* 解锁

        delete from methodLock where method_name = ‘method_name’
        
3、缺点

1、一旦数据库挂了，锁机制就失效了，过分依赖数据库
2、锁没有有效期，一旦在解锁时数据库挂了，这个操作就永远锁住了
3、缺少排队机制，锁只能时非阻塞的，线程要么得到锁，要么就得不到锁，不会进去排队等待

二、利用数据库的排他锁



### 基于缓存（redis等）实现分布式锁



### 基于Zookeeper实现分布式锁